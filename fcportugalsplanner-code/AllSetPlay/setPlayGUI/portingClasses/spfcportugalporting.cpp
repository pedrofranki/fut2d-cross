// -*-c++-*-

/* Changelog:
 - Joao Cravo, Luis Paulo Reis: Creation of tool, Version 1.3 (MsC FEUP -University of Porto-2011)
 (Detailed description of the Tool: http://hdl.handle.net/10216/62120, in portuguese)
 - Joao Fabro (joaofabro@gmail.com): Version 1.5 - Corrections and update (2014)
*/

 //Copyright:

 //Copyright (C) Joao Cravo and Luis Paulo Reis

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU LGPL as published by the Free Software  *
 *   Foundation; either version 2 of the License, or (at your option) any  *
 *   later version.                                                        *
 *                                                                         *
 ***************************************************************************/

// ADD HERE YOUR PORTING CLASS HEADER FILE
#include "spfcportugalporting.h"

#include "sppoint.h"
#include "spsetplay.h"
#include "spstep.h"
#include "spaction.h"
#include "spplayer.h"
#include "sptransition.h"
#include <QMessageBox>
#include <QFileDialog>

#include <fstream>
#include <ostream>

using namespace fcportugal::setplay;

QString SpFCPortugalPorting::lastImportDirectory = "./setPlayGUI/tests/";


SpFCPortugalPorting::SpFCPortugalPorting(SpSetPlay *s)
{
    spSetPlay = s;

}

bool SpFCPortugalPorting::importSetPlay(QString filename)
{

    if(filename.isEmpty())
        return false;

    lastImportDirectory = QFileInfo(filename).absoluteDir().absolutePath();

    string out = "";

    vector<string> text;
    string line;
    ifstream textstream(filename.toStdString().c_str());
    if(!textstream)
    {
        error = "No file found: " + filename +
                "\n\n Resolution: Choose an existent file.";
        return false;
    }
    while (getline(textstream, line))
    {
        text.push_back(line);
    }
    textstream.close();
    string alltext;
    for (unsigned int i=0; i < text.size(); i++)
    {
        size_t j = text[i].find('\t', 0);
        while(j!=string::npos)
        {
            text[i].replace(j,1," ");
            j = text[i].find("\t", 0);
        }
        alltext += text[i];
    }

    // comment and version
    string comment = "";

    int pos = -1;
    string versionString = ":version";
    string commentString = ":comment";

    pos = alltext.find(versionString, 0);
    if(pos != (int)string::npos)
    {
        pos += versionString.size() +1;
        int lpos = alltext.find_first_of("\n\t ",pos );
        string version = alltext.substr(pos, lpos - pos);
        if( (version != "splanner_1.5") && (version != "splanner_1.4") && (version != "splanner_1.3") && (version != "splanner_1.0") )
        {
            error = "Impossible to parse the setplay file: " + filename +
                    "\n\n Wasn't generated by Splanner. "+
                    "\n\n Resolution: Only files generated by SPlanner can be imported.";
        //    return false;
        }
    }
    else
    {
        error = "Impossible to parse the setplay file." + filename;
        //return false;
    }
    pos = alltext.find(commentString, 0);
    if(pos != (int)string::npos)
    {
        pos = alltext.find_first_of('(',pos) + 1;
        int lpos = alltext.find_first_of(')',pos);
        comment = alltext.substr(pos, lpos - pos );

    }

    //PARSE
    fcpsetplay = Setplay::parse(alltext,out,false,false,0);

    if(!fcpsetplay)
    {
        error = "SetPlay impossible to be parsed by FCPortugal SetPlay framework. \n\n" + error;
        return false;
    }
    if(!importingSpSetPlayInformation())
    {
        error = "Error generating SpSetPlay Information. \n\n" + error;
        return false;
    }
    if(!generateSpSteps())
    {
        error = "Error generating SpSteps.\n\n" + error;
        return false;
    }
    if(!generateSpTransitions())
    {
        error = "Error generating SpTransitions.\n\n" + error;
        return false;
    }

    foreach(Step *s , *(fcpsetplay->steps))
    {
        SpPlayer * leadPlayer = playerReferenceToSpPlayer(s->leadPlayer);
        if(!leadPlayer)
        {
            QString identification = "";
            if( dynamic_cast<PlayerRole*>(s->leadPlayer) )
                identification = QString(((PlayerRole *) s->leadPlayer)->roleName().c_str());
            else
                identification = " with number " + QString::number(((PlayerID *) s->leadPlayer)->number );
            error = " Error generating leadPlayer for step: " + QString::number(s->id)
                    + "\nPlayer " + identification + " doesn't have been referenced before on setplay participants!"
                    + "\n\n Resolution: manually verify and correct the error... it's about changing leadplayer name or number of step " + QString::number(s->id);
            return false;
        }
        if(leadPlayer && ! leadPlayer->isGhostOnStep(s->id))
            spSetPlay->setBallHolderOnStep(s->id, leadPlayer);
    }


    spSetPlay->setComment((QString)comment.c_str());

    return true;
}

bool SpFCPortugalPorting::exportSetPlay(QString filename)
{
    fcpsetplay = new Setplay(spSetPlay->getName().toStdString(),
                                    spSetPlay->getIdNumber(),
                                    true, true, 0);
#ifdef DEBUGEXPORT
        cerr << "SpFCPortugalPorting::exportSetplay(): Name=" << spSetPlay->getName().toStdString() <<
            " ID=" << spSetPlay->getIdNumber() << endl;//JAF2014
#endif
    fcpsetplay->setInvertible(spSetPlay->isInvertible());

    if(!generatePlayers())
    {
        error = "Error generating players:\n\n" + error;
        return false;
    }
#ifdef DEBUGEXPORT
    cerr << "SpFCPortugalPorting::exportSetplay(): finished generating Participant Players!" <<endl;
#endif
    fcpsetplay->abortCond = makeAbortCondition();
#ifdef DEBUGEXPORT
    cerr << "SpFCPortugalPorting::exportSetplay(): finished generating AbortConditions!" <<endl;
#endif
    fcpsetplay->steps = new vector<Step*>();
    foreach (SpStep * spStep, spSetPlay->getSteps())
    {
        Step* step = new Step(spStep->getIdNumber(),
                              spStep->getWaitTime(),
                              spStep->getAbortTime());

        if( ! generateStepParticipants(step) )
        {
#ifdef DEBUGEXPORT
            cerr << "SpFCPortugalPorting::exportSetplay(): Error generating step participants on step:" <<spStep->getIdNumber()<<endl;
#endif
            error = "Error generating step participants on step " + QString::number(spStep->getIdNumber()) + ":\n\n" + error;
            return false;
        }
        if( ! generateStepLeadPlayer(step) )
        {
#ifdef DEBUGEXPORT
            cerr << "SpFCPortugalPorting::exportSetplay(): Error generating step lead player on step:" <<spStep->getIdNumber()<<endl;
#endif
            error = "Error generating step lead player on step " + QString::number(spStep->getIdNumber()) + ":\n\n" + error;
            return false;
        }

        step->transitions = new vector< Transition *>();

        if(!generateStepConditions(spStep, step))
        {
#ifdef DEBUGEXPORT
            cerr << "SpFCPortugalPorting::exportSetplay(): Error generating step conditions on step:" <<spStep->getIdNumber()<<endl;
#endif
            error = "Error generating step conditions on step " + QString::number(spStep->getIdNumber()) + ":\n\n" + error;
            return false;
        }

        if(spStep->getType() == SpStep::end)
        {
            if( ! generateEndTransition(step) )
            {
#ifdef DEBUGEXPORT
                cerr << "SpFCPortugalPorting::exportSetplay(): Error generating end transition from step:" <<spStep->getIdNumber()<<endl;
#endif
                error = "Error generating end transition from step " + QString::number(spStep->getIdNumber()) + ":\n\n" + error;
                return false;
            }
        }
        else if (spStep->getType() == SpStep::abort)
        {
            if( ! generateAbortTransition(step) )
            {
#ifdef DEBUGEXPORT
                cerr << "SpFCPortugalPorting::exportSetplay(): Error generating abort transition from step:" <<spStep->getIdNumber()<<endl;
#endif
                error = "Error generating abort transition from step " + QString::number(spStep->getIdNumber()) + ":\n\n" + error;
                return false;
            }
        }
        else
        {
            if( ! generateTransitions(spStep, step) )
            {
#ifdef DEBUGEXPORT
                cerr << "SpFCPortugalPorting::exportSetplay(): Error generating transitions from step:" <<spStep->getIdNumber()<<endl;
#endif
                error = "Error generating transitions from step " + QString::number(spStep->getIdNumber()) + ":\n\n" + error;
                return false;
            }
        }
#ifdef DEBUGEXPORT
        cerr << "SpFCPortugalPorting::exportSetplay(): Finished Generating Step:" <<spStep->getIdNumber()<<endl;
#endif
        fcpsetplay->steps->push_back(step);
    }
#ifdef DEBUGEXPORT
    cerr << "SpFCPortugalPorting::exportSetplay(): Finished Generating Steps!" <<endl;
#endif
    ostringstream osString (ostringstream::out);
    osString.flush();

    fcpsetplay->write2(osString,1);

    // comment and version
    int pos = -1;
    string parametersString = ":parameters";
    string playersString = ":players";

    string text = osString.str();
    pos = text.find(parametersString, 0);
    if(pos == (int)string::npos)
        pos = text.find(playersString, 0);

    if(pos != (int)string::npos)
    {
        string toInsert = ":version splanner_1.5\n\t ";
        string comment = spSetPlay->getComment().toStdString();
        if(comment != "")
            toInsert += ":comment ( " + comment + " ) \n\t ";
        text.insert(pos, toInsert);
    }
#ifdef DEBUGEXPORT
    cerr << "SpFCPortugalPorting::exportSetplay(): saving to Output Stream!" <<endl;
#endif
    ofstream outFileStream(filename.toStdString().c_str(), ios::out);
    outFileStream << text << std::flush;
    outFileStream.close();
#ifdef DEBUGEXPORT
    cerr << "SpFCPortugalPorting::exportSetplay(): returning TRUE!" <<endl;
#endif

    return true;
}


bool SpFCPortugalPorting::exportSetPlay()
{
  /*  QString directoryName =  "./setPlayGUI/tests/";

    QFileDialog dialog((QWidget*)spSetPlay->getMainWindow(),
                       QString("Export setplay - " + spSetPlay->getName()), QString(lastExportDirectory + "/" + spSetPlay->getName() + ".conf"),
                       QString("SetPlay conf files (*.conf)"));



    dialog.setAcceptMode(QFileDialog::AcceptSave);

    QString filename;
    while(true)
    {
        dialog.close();
        if (!dialog.exec())
            return false;

        filename = dialog.selectedFiles()[0];
        QFileInfo file(filename);
        directoryName = dialog.directory().path();
        if(file.completeSuffix() == "conf" && !directoryName.isNull())
            break;
        QMessageBox::warning(spSetPlay, QString("Bad path or file name"),
            QString("Please choose .conf as extension, and a valid path!"));
        dialog.selectFile(file.baseName() + ".conf");
    }
    lastExportDirectory = QFileInfo(filename).absoluteDir().absolutePath();

    return exportSetPlay(filename);*/
    return false;
}

// Exporting

bool SpFCPortugalPorting::generatePlayers()
{
//    vector<const fcportugal::setplay::PlayerReference*> players =
//            cond.getFromPlayerSet();

//    fcpsetplay->players = new vector<PlayerReference*>();
    fcpsetplay->players.clear();
    SpPlayer *first = spSetPlay->getBallHolderOnStep(0);
    fcpsetplay->players.push_back( spPlayerToPlayerReference ( first) ); // HACK.. taker must be the first on list to avoid errors
    foreach (SpPlayer * spPlayer, spSetPlay->getParticipantPlayers())
        if(spPlayer != first)
            fcpsetplay->players.push_back( spPlayerToPlayerReference ( spPlayer) );

    return true;
}

Cond * SpFCPortugalPorting::makeAbortCondition()
{
    std::list< Cond* > bigAndCond;
    std::list< Cond* > bigOrCond;

    QList <int> abortConditions = spSetPlay->getAbortConditions();
    if(abortConditions.contains(theirBallCond))
    {
        vector<PlayerReference *> *v = new vector<PlayerReference *>();
        v->push_back(new PlayerID("opp", 0));
        const vector<const PlayerReference *> vconst(v->begin(), v->end());//JAF2014 turning non-const into const
        bigOrCond.push_back(new CondBallOwner(vconst));
    }
    if(abortConditions.contains(ourBallCond))
    {
        vector<PlayerReference *> *v = new vector<PlayerReference *>();
        v->push_back(new PlayerID("our", 0));
        const vector<const PlayerReference *> vconst(v->begin(), v->end());//JAF2014 turning non-const into const
        bigOrCond.push_back(new CondBallOwner(vconst));
    }
    if(abortConditions.contains(playOffCond))
    {
        Cond * situationCond = new CondPlayMode( situationToPlayMode(spSetPlay->getSituation() ,
                                                              spSetPlay->getType() ) );
        if(dynamic_cast<CondPlayMode *>(situationCond) &&
            dynamic_cast<CondPlayMode *>(situationCond)->getPlayMode() != rcss::clang::PlayOn) // is different play On
        {
            std::list< Cond* > andCond;
            andCond.push_back(new CondNot(new CondPlayMode(rcss::clang::PlayOn)));
            andCond.push_back(new CondNot(situationCond));
            bigOrCond.push_back(new CondAnd(andCond));
        }
        else
             bigOrCond.push_back(new CondNot(new CondPlayMode(rcss::clang::PlayOn)));
    }

    if(bigAndCond.size() > 1)
        return new CondAnd(bigAndCond);
    else if(bigOrCond.size() > 1)
        return new CondOr(bigOrCond);
    else if(bigOrCond.size() == 1)
        return (const_cast<Cond *>(bigOrCond.front()));
    else
        return NULL;
}

bool SpFCPortugalPorting::generateStepParticipants(Step *step)
{
    step->participants = new vector<Participation*>();

    QList<SpPlayer*> stepPlayers;

    if(step->id == 0) // HACK - On step 0, is needed all partipants to be instantiated to avoid errors..
        foreach(const PlayerReference *playerReference, fcpsetplay->players )
            stepPlayers.push_back(playerReferenceToSpPlayer(const_cast<PlayerReference *>(playerReference)));
    else
        foreach(const PlayerReference *playerReference, fcpsetplay->players )
        {
            SpPlayer *player = playerReferenceToSpPlayer(const_cast<PlayerReference *>(playerReference));
            if( !player->isGhostOnStep(step->id) )
                stepPlayers.push_back(player);
        }

    if(stepPlayers.isEmpty())
    {
        foreach(const PlayerReference *playerReference, fcpsetplay->players )
        {
            SpPlayer *player = playerReferenceToSpPlayer(const_cast<PlayerReference *>(playerReference));
            if( player->isParticipantOnStep(step->id) )
            {
                stepPlayers.push_back(player);
                break;
            }
        }
    }

    while(!stepPlayers.isEmpty())
    {
        SpPlayer * player = stepPlayers.takeFirst();
        SpPoint *pos = player->getStepPosition(step->id);
        if(pos->isRelative() == SpPoint::playerRelative)
        {
            SpPlayer *rp = pos->getRelativePlayer();
            if(stepPlayers.contains(rp))
            {
                stepPlayers.push_back(player);
                continue;
            }
        }
        Participation *participation;
        if( ! pos->isDummy() || pos->isDummy() == SpPoint::calculatedDummy)
        {
            fcportugal::setplay::Region *region = spPointToRegion( pos );
            participation = new Participation( spPlayerToPlayerReference(player), region );
        }
        else
            participation = new Participation(  spPlayerToPlayerReference(player) );
        step->participants->push_back(participation);
    }
    return true;
}

bool SpFCPortugalPorting::generateStepConditions(SpStep * spStep, Step *step)
{
    list < Cond * > conditions;
    vector<PlayerReference *> * onOffsideLinePlayers = new vector<PlayerReference *> ();

    //playmode
    CondPlayMode * condPM;
    if( spSetPlay->ballStoppedOnStep( spStep->getIdNumber() ) )
    {
        int sit = spSetPlay->getSituation();
        int type = spSetPlay->getType();
        condPM = new CondPlayMode(situationToPlayMode(sit,type));
    }
    else
        condPM = new CondPlayMode(rcss::clang::PlayOn);

    conditions.push_back(condPM);

    //ball pos regions
    if(spStep->getIdNumber() == 0)
    {
//        cerr << "SpFCPortugalPorting::generateStepConditions() to Step 0"<<endl;
        list < Cond * > condOrRegions;
        list < Cond * > condAndRegions;

        QList <int> RegionsList = spSetPlay->getRegions();
        QList <int> TransverseRegionsList = spSetPlay->getTransverseRegions();//JAF2014

        QSet <int> RegionsSet = RegionsList.toSet();//JAF2014 Conversion to Sets ->subtract Transverse areas!
        QSet <int> TransverseRegionsSet = TransverseRegionsList.toSet();
        QSet <int> newRegionsSet = RegionsSet.operator-(TransverseRegionsSet);
        QList <int> newRegionsList = newRegionsSet.toList();

//        if(newRegionsList.isEmpty())//meaning that there may be only Transverse Regions....
//        {
//            newRegionsList.append(9999);//JAF2014 Not a valid region, used only to enter foreach bellow
//        }
        foreach(int r, newRegionsList )
        {
            if(r == field || r == point)
                continue;
            RegNamed *reg = new RegNamed(setPlayRegionsNames[r]);
            CondBallPos *cond = new CondBallPos(reg);

//            if(r != right_region && r != left_region &&
//               r != far_left     && r != mid_left    && r != centre_left &&
//               r != centre_right && r != mid_right   && r != far_right)
//            {
//                condOrRegions.push_back(cond);
//                cerr << " Region to be inserted(OR): " << setPlayRegionsNames[r] << endl;
//            }
//            else
//            {
//                condAndRegions.push_back(cond);
//                cerr << " Region to be inserted(AND): " << setPlayRegionsNames[r] << endl;
//            }

            if(!TransverseRegionsList.isEmpty())
                foreach(int tr, TransverseRegionsList )
                {
                  RegNamed *t_reg = new RegNamed(setPlayRegionsNames[tr]);
                  CondBallPos *t_cond = new CondBallPos(t_reg);
//                  cout << " AND Condition: " << setPlayRegionsNames[r] << " &&" << setPlayRegionsNames[tr] << endl;

                  condAndRegions.clear();//Make sure is empty
                  condAndRegions.push_back(cond);
                  condAndRegions.push_back(t_cond);

                  CondAnd *newAndCond = new CondAnd(condAndRegions);
                  condOrRegions.push_back(newAndCond);
                }
            else // TransverseRegionsList is in fact Empty!
            {
                condOrRegions.push_back(cond);
//                cout << " Just OR condition: " << setPlayRegionsNames[r] << endl;
            }
        }
        if(newRegionsList.isEmpty())//meaning that there may be only Transverse Regions....
          if(!TransverseRegionsList.isEmpty())
             foreach(int tr, TransverseRegionsList )
             {
               RegNamed *t_reg = new RegNamed(setPlayRegionsNames[tr]);
               CondBallPos *t_cond = new CondBallPos(t_reg);
//               cout << " OR Condition: " << setPlayRegionsNames[tr] << endl;
               condOrRegions.push_back(t_cond);
             }

        if(condOrRegions.size() > 0)
        {
            if(condOrRegions.size() > 1)
            {
                CondOr * condOr = new CondOr(condOrRegions);
                conditions.push_back(condOr);
            }
            else
                conditions.push_back(condOrRegions.front());
        }
//        if(condAndRegions.size() > 0)
//        {
//            if(condAndRegions.size() > 1)
//            {
//                CondAnd * condAnd = new CondAnd(condAndRegions);
//                conditions.push_back(condAnd);
//            }
//            else
//                conditions.push_back(condAndRegions.front());
//        }
    }

    foreach (Participation *participation , *(step->participants))
    {
        PlayerReference *pr = (PlayerReference *) participation->participant();
        SpPlayer *player = playerReferenceToSpPlayer(pr);
        if(!player)
        {
            QString identification = "";
            if( dynamic_cast<PlayerRole*>(pr) )
                identification = QString(((PlayerRole *) pr)->roleName().c_str());
            else
                identification = " with number " + QString::number(((PlayerID *) pr)->number );
            error = " Error generating step conditions for step: " + QString::number(step->id)
                    + "\nPlayer " + identification + " doesn't have be referenced before on setplay participants!"
                    + "\n\n Resolution: manually verify and correct the error... it's about changing player name or number on step "
                    + QString::number(step->id) + " condition";

            return false;
        }

        QList<int> stepConds = player->getStepConditions(spStep->getIdNumber());

        vector<PlayerReference *> * playersReference = new vector<PlayerReference *> ();
        playersReference->push_back(pr);

	const vector<const PlayerReference *> pRconst(playersReference->begin(), playersReference->end());//JAF2014 turning non-const into const

        if(stepConds.size())
        {
            foreach(int cond, stepConds)
            {
                if(cond == ppos)
                {
                    fcportugal::setplay::Region *point = spPointToRegion(player->getStepPosition(spStep->getIdNumber()));
                    Integer *a = new Integer(1);//TODO THIS integers...
                    Integer *b = new Integer(22);
//                    CondPlayerPos * cond = new const CondPlayerPos(playersReference, point, a, b);
                    CondPlayerPos * cond = new CondPlayerPos(pRconst, point, a, b);//JAF2014

                    conditions.push_back(cond);
                }
                else if(cond == bowner )
                {
//                    CondBallOwner * cond = new const CondBallOwner(playersReference);
                    CondBallOwner * cond = new CondBallOwner(pRconst);//JAF2014

                    // TODO take this if when setplay library correct this error
                    if(spStep->getIdNumber() == 0)
                        if( dynamic_cast<PlayerRole*> (pr))
                            continue;

                    conditions.push_back(cond);
                }
                else if(nearOffsideLine)
                {
                    onOffsideLinePlayers->push_back(pr);
                }
            }
        }

        if(onOffsideLinePlayers->size() > 0)
        {
//            CondNearOffsideLine * cond = new const CondNearOffsideLine(playersReference);
            CondNearOffsideLine * cond = new CondNearOffsideLine(pRconst);//JAF2014
            conditions.push_back(cond);
        }

    const list < Cond * > constConditions(conditions.begin(), conditions.end());//JAF2014  conversion to const list

        if(constConditions.size())
        {
            if(constConditions.size() > 1)
            {

                CondAnd * cAnd = new CondAnd(constConditions);
                step->condition = cAnd;
            }
            else
            {
	        step->condition = (const_cast<Cond *>(constConditions.front()));//JAF2014 DANGER!!!
            }
        }
    }
    return true;
}

bool SpFCPortugalPorting::generateStepLeadPlayer(Step *step)
{
    SpPlayer *player = spSetPlay->getBallHolderOnStep(step->id);
    if(! player)
    {
        PlayerRole * pr = (PlayerRole * ) step->participants->at(0)->participant();
        step->leadPlayer = new PlayerRole(pr->roleName().c_str());
    }
    else
        step->leadPlayer = spPlayerToPlayerReference ( player);
    return true;
}

bool SpFCPortugalPorting::generateTransitions(SpStep * spStep, Step *step)
{
    foreach(SpTransition *spTransition, spStep->getSourceTransitionsList())
    {
        NextStep *transitionNextStep = new NextStep( spTransition->getDest()->getIdNumber(), NULL, NULL);

        if(! generateDirectivesToTransition(spTransition, transitionNextStep, step) )
            return false;
        if(! generateConditionsToTransition(spTransition, transitionNextStep, step) )
            return false;

        step->transitions->push_back(transitionNextStep);
    }
    return true;
}

SpTransition * SpFCPortugalPorting::generateTransition(Step * s, Transition *t)
{
    SpTransition *newT = NULL;

    if(t->isNextStep())
    {
        NextStep *tns =  (NextStep *) t;
        SpStep * nextStep = spSetPlay->getStep(tns->nextStepNumber);
        if(!nextStep)
        {
            error = "Error generating transition on step " + QString::number( s->id) +" : invalid destination.\n "
                    + "Step " + QString::number(tns->nextStepNumber) + "doen't exist!"
                    + "\n\n Resolution: contact splanner developer."
                    + QString::number(s->id);

            return NULL;
        }

        newT = spSetPlay->getStep(s->id)->addSourceTransition(nextStep);
    }
    return newT;
}

bool SpFCPortugalPorting::generateAbortTransition(Step * step)
{
    Abort *abort = new Abort();
    step->transitions->push_back(abort);
    return true;
}

bool SpFCPortugalPorting::generateEndTransition(Step * step)
{
    Finish *finish = new Finish();
    step->transitions->push_back(finish);
    return true;
}

bool SpFCPortugalPorting::generateConditionsToTransition(SpTransition * spTransition, NextStep * transitionNextStep,
                                     Step *step)
{
    list < Cond * > conditions;

    foreach (Participation *participation , *(step->participants))
    {
       PlayerReference *pr = (PlayerReference *) participation->participant();
        SpPlayer *player = playerReferenceToSpPlayer(pr);
        if(!player)
        {
            QString identification = "";
            if( dynamic_cast<PlayerRole*>(pr) )
                identification = QString(((PlayerRole *) pr)->roleName().c_str());
            else
                identification = " with number " + QString::number(((PlayerID *) pr)->number );
            error = " Error generating conditions for transition on step: " + QString::number(step->id)
                    + "\nPlayer " + identification + " doesn't have be referenced before on setplay!"
                    + "\n\n Resolution: contact Splanner developers ";

            return false;
        }

        int conAction = player->getTransitionCondition(spTransition->getIdNumber());

        vector<PlayerReference *> * playersRef = new vector<PlayerReference *>();
        playersRef->push_back(pr);

	const vector<const PlayerReference *> constplayersRef(playersRef->begin(), playersRef->end());//JAF2014 converting to const
        	
        SpAction *action = player->getActionByTransition(spTransition->getIdNumber());

//        cerr << "SpFCPortugalPorting::generateConditionsToTransition() ActionbyTransition(" << spTransition->getIdNumber() <<")"<< endl;
//        cerr << "conAction = ";
//        if (conAction== canPassPlayer) cerr << "canPassPlayer";
//        else if (conAction== canPassRegion) cerr << "canPassRegion";
//        else if (conAction== canShoot) cerr << "canShoot";
//        else if (conAction== -1) cerr << "-1?";
//        else cerr << "outro valor = " << conAction;
        if(conAction != -1)
        {
            if(conAction == canPassPlayer)
            {
                PlayerReference *pr = spPlayerToPlayerReference ( action->getDestActor());
                vector<PlayerReference *> * playersRefTo = new vector<PlayerReference *>();
                playersRefTo->push_back(pr);
                const vector<const PlayerReference *> constplayersRefTo(playersRefTo->begin(), playersRefTo->end());//JAF2014 converting to const
                CondClearPassToPlayer *cond = new CondClearPassToPlayer(constplayersRef, constplayersRefTo);
                conditions.push_back(cond);
            }
            else if(conAction == canPassRegion)
            {
                fcportugal::setplay::Region *region = spPointToRegion(action->getSpDest());
                CondClearPassToRegion *cond = new CondClearPassToRegion(constplayersRef,region);
                conditions.push_back(cond);
            }
            else if(conAction == canShoot)
            {
                CondClearShotAtGoal *cond = new CondClearShotAtGoal(constplayersRef);
                conditions.push_back(cond);
            }
            else
            {
                error = "Error generating condition to one transition of step:" +  QString::number(step->id)
                        + "\n Some Splanner condition didn't have pair for FCPortugal Setplay framework."
                        + "\n\n Unfortunately, you have to contact the Splanner developer...";
                return false;
            }
        }
    }
    if(conditions.size())
    {
        if(conditions.size() > 1)
        {
            CondAnd *cAnd = new CondAnd(conditions);
            transitionNextStep->setCond(cAnd);
        }
        else
            transitionNextStep->setCond(conditions.front());
    }
    return true;
}

bool SpFCPortugalPorting::generateDirectivesToTransition(SpTransition *spTransition, NextStep *transitionNextStep,
                                                Step *step)
{
    QMap<SpPlayer *, vector<Action *> * > playerActionOnTransition;
    SpPlayer * receiveBallPlayer = NULL;
    int type = 0;

    foreach (Participation *participation , *(step->participants))
    {
        PlayerReference *pr = (PlayerReference *) participation->participant();
        SpPlayer *player = playerReferenceToSpPlayer(pr);
        if(!player)
        {
            QString identification = "";
            if( dynamic_cast<PlayerRole*>(pr) )
                identification = QString(((PlayerRole *) pr)->roleName().c_str());
            else
                identification = " with number " + QString::number(((PlayerID *) pr)->number );
            error = " Error generating directives to transition for step: " + QString::number(step->id)
                    + "\nPlayer " + identification + " doesn't have be referenced before on setplay participants!"
                    + "\n\n Resolution: contact Splanner developer. ";

            return false;
        }
        SpAction *spAction = player->getActionByTransition(spTransition->getIdNumber());
        if(! spAction)
            continue;
        vector<Action *> * playerActions = new vector<Action *>();

        Action * action = generateAction(spAction);
        if(action != NULL)
        {
            playerActions->push_back(action);
            type = spAction->getType();
            if(spAction->getType() == SpAction::pass || spAction->getType() == SpAction::passForward)
                receiveBallPlayer = spAction->getDestActor();
        }
        else
        {
            error = " Error generating directives to transition for step: " + QString::number(step->id)
                    + "\n\n" + error;

            return false;
        }

        playerActionOnTransition[player] = playerActions;
    }

    if(receiveBallPlayer)
    {
        Action * act;
        if(type == SpAction::pass)
            act = new ActReceiveBall();
        else
            act = new ActIntercept();

        if(playerActionOnTransition.contains(receiveBallPlayer))
        {
//            playerActionOnTransition[receiveBallPlayer]->clear();//JAF2014
              std::vector<Action *>::iterator iteratorAction;////JAF2014
              iteratorAction = playerActionOnTransition[receiveBallPlayer]->begin();////JAF2014
              playerActionOnTransition[receiveBallPlayer]->insert(iteratorAction, act);////JAF2014
              //playerActionOnTransition[receiveBallPlayer]->push_back(act);
        }
        else
        {
            vector<Action *> * playerActions  = new vector<Action *>();
            playerActions->push_back(act);
            playerActionOnTransition[receiveBallPlayer] = playerActions;
        }
    }

    vector<Directive*> *directives = new vector<Directive*>();

    foreach (SpPlayer * player, playerActionOnTransition.keys())
    {
         PlayerReference *pr = spPlayerToPlayerReference ( player);
         Directive *newDirective = generateDirective( pr, playerActionOnTransition[player]);
         if(newDirective)
             directives->push_back(newDirective);
         else
         {
             error = "Error generating one directive to transition for step" + QString::number(step->id)
                   + "\n\n Resolution: contact Splanner developer ";
             return false;
         }
    }

    transitionNextStep->setDirectives(directives);
    return true;
}

Directive * SpFCPortugalPorting::generateDirective(PlayerReference *playerReference, vector<Action*> * actions)
{
    vector<PlayerReference *> *playerVector = new vector<PlayerReference *>();
    playerVector->push_back(playerReference);

    const vector<const PlayerReference *> pVconst(playerVector->begin(), playerVector->end());//JAF2014 turning non-const into const

    return new Do(pVconst, actions );
}

Action * SpFCPortugalPorting::generateAction(SpAction *spAction)
{
    if(spAction->getType() == SpAction::passForward)
    {
        fcportugal::setplay::Region *region = spPointToRegion(spAction->getSpDest());
        return new ActForward(region);
    }
    else if(spAction->getType() == SpAction::pass)
    {
        SpPlayer *dest = spAction->getDestActor();
        vector<const PlayerReference *> * players = new vector<const PlayerReference *>();
        players->push_back(spPlayerToPlayerReference (dest));
        return new ActPass(*players);
    }
    else if(spAction->getType() == SpAction::run)
    {
        fcportugal::setplay::Region *region = spPointToRegion(spAction->getSpDest());
        return new ActPos(region);
    }
    else if(spAction->getType() == SpAction::dribble)
    {

        fcportugal::setplay::Region *region = spPointToRegion(spAction->getSpDest());
        return new ActDribble(region);
    }
    else if(spAction->getType() == SpAction::shoot)
    {
        return new ActShoot();
    }
    else if(spAction->getType() == SpAction::wait)
    {
        return new ActStop();
    }
    else if(spAction->getType() == SpAction::hold)
    {
        return new ActHold();
    }
    else if(spAction->getType() == SpAction::goToOffsideLine)
    {
        QPointF pos = spAction->getSpDest()->getRealPoint();
        return new ActMoveToOffsideLine(new Decimal(pos.y()));
    }
    else
    {
        error = "Error generating action -" + spAction->print()
                + "\n\n Resolution: contact Splanner developer ";

        return NULL;
    }
    return NULL;//Just to avoid warning in compiling
}

PlayerReference * SpFCPortugalPorting::spPlayerToPlayerReference(SpPlayer *sp)
{
    if(sp->isIdentificatedByNumber())
        return new PlayerID("our", sp->getNumber());
    else
        return new PlayerRole(sp->getName().toStdString());
}

rcss::clang::PlayMode SpFCPortugalPorting::situationToPlayMode(int situation, int type)
{
    if(situation == play_on )
        return rcss::clang::PlayOn;
    else if(situation == keeper_catch)
        return type == off ? rcss::clang::GoalieCatch_Our : rcss::clang::GoalieCatch_Opp;
    else
    {
        int s = (situation-1) * 4 + 4;

        if(type == def)
            s+=2;

        return (rcss::clang::PlayMode) s;
    }
}

RegPoint *SpFCPortugalPorting::qpointToRegPoint(QPointF pos)
{
    return new RegPoint( new PointSimple( new Decimal(pos.x()), new Decimal(pos.y()) ) );
}


fcportugal::setplay::Region * SpFCPortugalPorting::spPointToRegion(SpPoint *sp)
{

    int rel = sp->isRelative();
    if(rel)
    {
        //cout << "SpFCPortugalPorting::spPointToRegion() - calculating relative position." << endl;//JAF2014
        Point * origin=NULL;
        if(rel == SpPoint::ballRelative)
            origin = new PointBall();
        else if(rel == SpPoint::playerRelative )
            origin = new PointPlayer(spPlayerToPlayerReference(sp->getRelativePlayer()));
        else if(rel == SpPoint::pointRelative)
        {
            QPointF ps = sp->getRelativePoint();
            origin = new PointSimple(new Decimal(ps.x()), new Decimal(ps.y()));
        }

        QPointF ps =  sp->getOffsetPoint();

        PointRel *pr = new PointRel(new Decimal(ps.x()), new Decimal(ps.y()), origin);
//        cout << "SpFCPortugalPorting::spPointToRegion() Origin= ";//JAF2014
//        origin->print(cout);//JAF2014
//        cout << "SpFCPortugalPorting::spPointToRegion() Offset x=" << sp->getOffsetPoint().x()<< " y=" << sp->getOffsetPoint().y() << endl;//JAF2014
        return new RegPoint(pr);
    }
    else
        return qpointToRegPoint( sp->getRealPoint());
}

// Importing

bool SpFCPortugalPorting::importingSpSetPlayInformation()
{
    spSetPlay->setName(QString(fcpsetplay->name.c_str()));
    spSetPlay->setIdNumber(fcpsetplay->id());

    spSetPlay->setInvertible(fcpsetplay->isInvertible());

    if(!generateSpAbortConditions())
        return false;

    int i = 1;

    foreach(const PlayerReference* pr , fcpsetplay->players )
    {
        SpPlayer * spPlayer ;
        QString name;
        if( dynamic_cast<PlayerRole*>(const_cast<PlayerReference*>(pr)) )//JAF2014 No problem using const_cast since will not change pr!
        {
            PlayerRole * role = (PlayerRole *) pr;
            name = QString(role->roleName().c_str());
            while(true)
            {
                spPlayer = spSetPlay->getPlayer(i);
                i++;
                if(! spPlayer->isIdentificatedByNumber() || ! spPlayer)
                    break;
            }
        }
        else
        {
             PlayerID * p = (PlayerID *) pr;
             spPlayer = spSetPlay->getPlayer(p->number);
             spPlayer->setIdentificationByNumber(true);
             name = "Player" + QString::number(p->number);
        }

        //name
        int f = 2;
        while( true )
        {
            SpPlayer *sameNamePlayer = spSetPlay->getPlayer(name);
            if(! sameNamePlayer || sameNamePlayer == spPlayer)
                break;

            name = name + "_" + QString::number(f++);
        }
        // if(f != 2 ) TODO MENSAGEM ERRO para perguntar se quer seguir com o novo nome...
        spPlayer->setName(name);
    }
    return true;
}

bool SpFCPortugalPorting::generateSpAbortConditions()
{
    Cond * cond = fcpsetplay->abortCond;

    QList <Cond *>  conditions;
    if(!cond)
        return true;
    conditions.append(cond);

    while(! conditions.isEmpty())
    {
        cond = conditions.takeFirst();

        if(dynamic_cast<CondNot*>(cond) )
        {
            CondNot* condNot = dynamic_cast<CondNot*>(cond);
            Cond *c = const_cast<Cond *>(condNot->getCond());
            conditions.push_back(c);
        }
        else if( dynamic_cast<CondAnd*>(cond) )
        {
            CondAnd* condAnd = dynamic_cast<CondAnd*>(cond);
            foreach(const Cond *c, condAnd->getConds())
                conditions.push_back(const_cast<Cond *>(c));//TODO turn every condition const
        }
        else if(dynamic_cast<CondOr*>(cond) )
        {
            CondOr* condOr = dynamic_cast<CondOr*>(cond);
            foreach(const Cond *c, condOr->getConds())
                conditions.push_back(const_cast<Cond *>(c));//TODO turn every condition const
        }
        else if(dynamic_cast<CondBallOwner*>(cond) )
        {
            CondBallOwner * condBallOwner = dynamic_cast<CondBallOwner*>(cond);
            if(spSetPlay->getAbortConditions().contains(ourBallCond) || spSetPlay->getAbortConditions().contains(theirBallCond))
                continue;
            const vector<const PlayerReference *> v = condBallOwner->getPlayerSet();
            if(((PlayerID *) v.at(0))->team == "our")
                spSetPlay->addToAbortConditions(ourBallCond);
            else
                spSetPlay->addToAbortConditions(theirBallCond);
        }
        else if( dynamic_cast<CondPlayMode*>(cond) )
        {
            if(spSetPlay->getAbortConditions().contains(playOffCond))
                continue;
            spSetPlay->addToAbortConditions(playOffCond);
        }
        else
        {
            error = "Error generating abort conditions. \n Some abort condition from setplay haven't pair on Splanner setplay conditions \
                    \n\n Resolution: manually verify and correct the error... it's about changing or remove one abort condition.";

            return false;
        }
    }
    return true;
}

bool SpFCPortugalPorting::generateSpSteps()
{

    foreach(Step *s , *(fcpsetplay->steps))
    {
        SpStep *newStep = new SpStep(spSetPlay, s->id, s->waitTime, s->abortTime);
        newStep->init();
        newStep->setAutomaticAbortTime(false);
        spSetPlay->addStep(newStep);

        if(!generateSpStepConditions(s, newStep))
            return false;

        int stepIdNumber = newStep->getIdNumber();

        foreach(Participation *participation , *(s->participants))
        {
            PlayerReference * pr = (PlayerReference *) participation->participant();
            SpPlayer * player = playerReferenceToSpPlayer(pr);
            if(!player)
            {
                QString identification = "";
                if( dynamic_cast<PlayerRole*>(pr) )
                    identification = QString(((PlayerRole *) pr)->roleName().c_str());
                else
                    identification = " with number " + QString::number(((PlayerID *) pr)->number );
                error = " Error generating step: " + QString::number(s->id)
                        + "\nPlayer " + identification + " doesn't have be referenced before on setplay participants!"
                        + "\n\n Resolution: manually verify and correct the error... it's about changing player name or number on step "
                        + QString::number(s->id);

                return false;
            }

            SpPoint * spPoint;
            if(participation->location() == NULL)
            {
                spPoint = new SpPoint(spSetPlay->getField(),false, QPointF(0,0));
                spPoint->setDummy();
            }
            else
            {
                spPoint = regionToSpPoint(participation->location());
            }

            player->setPositionOnStep(stepIdNumber, spPoint);
            player->createParticipionTransitionSet(stepIdNumber);
        }

    }
    return true;
}

bool SpFCPortugalPorting::generateSpStepConditions(Step *step, SpStep *spStep)
{
    Cond * cond = step->condition;

    QList <Cond *>  conditions;
    if(!cond)
       return  true;
    conditions.append(cond);

    while(! conditions.isEmpty())
    {
        cond = conditions.takeFirst();

        if(dynamic_cast<CondNot*>(cond) )
        {
            CondNot* condNot = dynamic_cast<CondNot*>(cond);
            Cond *c = const_cast<Cond *>(condNot->getCond());
            conditions.push_back(c);
        }
        else if( dynamic_cast<CondAnd*>(cond) )
        {
            CondAnd* condAnd = dynamic_cast<CondAnd*>(cond);
            foreach(const Cond *c, condAnd->getConds())
                conditions.push_back(const_cast<Cond *>(c));//TODO turn every condition const
        }
        else if(dynamic_cast<CondOr*>(cond) )
        {
            CondOr* condOr = dynamic_cast<CondOr*>(cond);
            foreach(const Cond *c, condOr->getConds())
                conditions.push_back(const_cast<Cond *>(c));//TODO turn every condition const
        }
        else if(dynamic_cast<CondPlayerPos*>(cond) )
        {
            CondPlayerPos * condPlayerPos = dynamic_cast<CondPlayerPos*>(cond);
            const vector<const PlayerReference *> v = condPlayerPos->getPlayerSet();
            SpPlayer * player = playerReferenceToSpPlayer(v.at(0));
            player->addStepCondition(spStep->getIdNumber(), ppos);
        }
        else if(dynamic_cast<CondNearOffsideLine*>(cond) )
        {
            CondNearOffsideLine * condNearOffsideLine = dynamic_cast<CondNearOffsideLine*>(cond);
            const vector<const PlayerReference *> v = condNearOffsideLine->getPlayerSet();
            for(unsigned int i = 0; i < v.size(); i++)
            {
                SpPlayer * player = playerReferenceToSpPlayer(v.at(i));
                player->addStepCondition(spStep->getIdNumber(), nearOffsideLine);
            }
        }
        else if(dynamic_cast<CondBallOwner*>(cond) )
        {
            CondBallOwner * condBallOwner = dynamic_cast<CondBallOwner*>(cond);
            const vector<const PlayerReference *> v = condBallOwner->getPlayerSet();
            SpPlayer * player = playerReferenceToSpPlayer(v.at(0));
            player->addStepCondition(spStep->getIdNumber(), bowner);
        }
        else if(dynamic_cast<CondPlayMode*>(cond) )      //playmode
        {
            CondPlayMode * condPlayMode = dynamic_cast<CondPlayMode*>(cond);
            int sit = -1;
            int type = -1;
            playmodeToSituation(condPlayMode->getPlayMode(), sit, type);
            if(sit > -1 && type > -1)
            {
                if(spStep->getIdNumber() == 0)
                {
                    spSetPlay->setSituation(sit);
                    spSetPlay->setType(type);
                }
                if (sit != play_on)
                    spSetPlay->setBallStoppedOnStep(spStep->getIdNumber());
            }
        }
        else if(dynamic_cast<CondBallPos*>(cond) ) //regions
        {

            CondBallPos * condBallPos = dynamic_cast<CondBallPos*>(cond);
            RegNamed * regN = (RegNamed *) condBallPos->getRegion();

            QString name = QString(regN->regionName().c_str());

            for(int i= 0; i < setPlayRegionsNumber; i++)
            {
                if(setPlayRegionsNames[i] == name )
                {
                //    cerr << "spfcportugalporting::generateSpStepConditions(): Condition BallPos: name = " << setPlayRegionsNames[i];
                    if( (strcmp(setPlayRegionsNames[i],"left_region")!=0)&&   //JAF2014 to include
                        (strcmp(setPlayRegionsNames[i],"right_region")!=0)&& // TransverseRegions(left, right, etc)
                        (strcmp(setPlayRegionsNames[i],"far_left")!=0)&&      // inside addTransverseRegion()
                        (strcmp(setPlayRegionsNames[i],"mid_left")!=0)&&      // and all others
                        (strcmp(setPlayRegionsNames[i],"centre_left")!=0)&&   // inside addRegion()
                        (strcmp(setPlayRegionsNames[i],"far_right")!=0)&&
                        (strcmp(setPlayRegionsNames[i],"mid_right")!=0)&&
                        (strcmp(setPlayRegionsNames[i],"centre_right")!=0)
                      )
                    {
                       if(!(spSetPlay->getRegions()).contains(i))
                       {
                                spSetPlay->addRegion(i);
                //                cerr << setPlayRegionsNames[i] << "(regular region)" << endl;
                       }
                    }
                    else
                    {
                        if(!(spSetPlay->getTransverseRegions()).contains(i))
                        {
                                spSetPlay->addTransverseRegion(i);
                //                cerr << setPlayRegionsNames[i] << "(transverse)" << endl;
                        }
                    }
                    break;
                }
            }
        }
        else
        {
            error = " Error generating step conditions for step: " + QString::number(step->id)
                    + "\nThe condition from setplay file haven't pair on Splanner conditions."
                    + "\n\n Resolution: manually verify and correct the error... it's about changing one or more conditions of step "
                    + QString::number(step->id);

            return false;
        }
    }
    return true;
}

bool SpFCPortugalPorting::generateSpTransitions()
{
    foreach(Step *s , *(fcpsetplay->steps))
    {
        foreach(Transition *t , *(s->transitions))
        {
            if(!t->isNextStep())
                continue;

            SpTransition *spTransition = generateTransition(s, t);

            if(spTransition == NULL)
                return false;

            foreach(Participation *participation , *(s->participants))
            {
                PlayerReference * pr = (PlayerReference *) participation->participant();
                SpPlayer * player = playerReferenceToSpPlayer(pr);
                player->setParticipantOnStepByTransition(s->id, spTransition->getIdNumber());
            }

            if(!generateSpTransitionConditions(t, spTransition))
                return false;
            if(!generateSpActions(t, spTransition))
                return false;

        }

    }
    return true;
}

bool SpFCPortugalPorting::generateSpTransitionConditions(Transition *transition, SpTransition *spTransition)
{
    Cond * cond = transition->getCond();

    QList <Cond *>  conditions;
    if(!cond)
        return true;
    conditions.append(cond);

    while(! conditions.isEmpty())
    {
        cond = conditions.takeFirst();

        if(dynamic_cast<CondNot*>(cond) )
        {
            CondNot* condNot = dynamic_cast<CondNot*>(cond);
            Cond *c = const_cast<Cond *>(condNot->getCond());
            conditions.push_back(c);
        }
        else if( dynamic_cast<CondAnd*>(cond) )
        {
            CondAnd* condAnd = dynamic_cast<CondAnd*>(cond);
            foreach(Cond *c, condAnd->getConds())
                conditions.push_back(c);
        }
        else if(dynamic_cast<CondOr*>(cond) )
        {
            CondOr* condOr = dynamic_cast<CondOr*>(cond);
            foreach(Cond *c, condOr->getConds())
                conditions.push_back(c);
        }
        else if(dynamic_cast<CondClearShotAtGoal*>(cond) )
        {
            CondClearShotAtGoal * condClearShotAtGoal = dynamic_cast<CondClearShotAtGoal*>(cond);
            const vector<const PlayerReference *> v = condClearShotAtGoal->getFromPlayerSet();
            SpPlayer * player = playerReferenceToSpPlayer(v.at(0));
            player->changeTransitionCondition(spTransition->getIdNumber(), canShoot);
        }
        else if(dynamic_cast<CondClearPassToPlayer*>(cond) )
        {
            CondClearPassToPlayer * condClearPassToPlayer = dynamic_cast<CondClearPassToPlayer*>(cond);
            const vector<const PlayerReference *> from = condClearPassToPlayer->getFromPlayerSet();
            SpPlayer * player = playerReferenceToSpPlayer(from.at(0));
            player->changeTransitionCondition(spTransition->getIdNumber(), canPassPlayer);
        }
        else if(dynamic_cast<CondClearPassToRegion*>(cond) )
        {
            CondClearPassToRegion * condClearPassToRegion = dynamic_cast<CondClearPassToRegion*>(cond);
            const vector<const PlayerReference *> v = condClearPassToRegion->getFromPlayerSet();
            SpPlayer * player = playerReferenceToSpPlayer( v.at(0) );
            player->changeTransitionCondition(spTransition->getIdNumber(), canPassRegion);
        }
        else
        {
            error = "Error generating transition conditions to transition between: " +
                    QString::number(spTransition->getSource()->getIdNumber()) + " and " +
                    QString::number(spTransition->getDest()->getIdNumber()) + ":\n" +
                    + "\nCondition from setplay file haven't pair for splanner conditions" +
                    + "\n\n Resolution: manually verify and correct the error... it's about changing or remove condition of"
                    + " transitions from step "+ QString::number(spTransition->getSource()->getIdNumber()) + " to "
                    + QString::number(spTransition->getDest()->getIdNumber());

            return false;
        }
    }
    return true;
}

bool SpFCPortugalPorting::generateSpActions(Transition *t , SpTransition * spTransition)
{
    Action *passForward = NULL;
    SpPlayer *passForwardActor = NULL;
    QList<SpPlayer *> participants;

    foreach(Directive *d , *(t->getDirectives()))
    {
        foreach(const PlayerReference *pr , (d->getPlayers()))
        {
            SpPlayer * player = playerReferenceToSpPlayer(pr);
            if(!player)
            {

                QString identification = "";
                if(dynamic_cast<PlayerRole*>(const_cast<PlayerReference *>(pr)) )//JAF2014 no problem using const_cast, will no alter pr value!!!
//                if(pr!=NULL )
                    identification = QString(((PlayerRole *) pr)->roleName().c_str());
                else
                    identification = " with number " + QString::number(((PlayerID *) pr)->number );
                error = " Error generating action on transition between " +
                        QString::number(spTransition->getSource()->getIdNumber()) + " and " +
                        QString::number(spTransition->getDest()->getIdNumber()) + ":\n" +
                        + "\nPlayer " + identification + " doesn't have be referenced before on setplay participants!"
                        + "\n\n Resolution: manually verify and correct the error... it's about changing player name or number of action in "
                        + "transition from step "+ QString::number(spTransition->getSource()->getIdNumber()) + " to "
                        + QString::number(spTransition->getDest()->getIdNumber());

                return false;
            }
            participants.append(player);
            foreach(Action *act , *(d->getActions()))
            {
                if(act->actionType() == 'f')
                {
                    passForward = act;
                    passForwardActor = player;
                }
                else if( ! generateSpAction(player, spTransition, act) )
                    return false;
            }
        }
    }

    if(passForward && ! generateSpPassForward(passForwardActor, spTransition, passForward, participants))
    {

        error = " Error generating a passforward on transition between " +
                QString::number(spTransition->getSource()->getIdNumber()) + " and " +
                QString::number(spTransition->getDest()->getIdNumber()) + ":\n" +
                + "\nProbabily one of those situations ocorred: "
                + "\n\t - There aren't a player on step " + QString::number(spTransition->getSource()->getIdNumber()) + " that receive or intercept the ball"
                + "\n\t - The player on step " + QString::number(spTransition->getSource()->getIdNumber()) + " that receive or intercept the ball is not running for the right position."
                + "\n\n Resolution: manually verify and correct the error on the file... it's about adding a action receive/intercept or changing coordenates "
                + "of run (ppos) action.";

        return false;
    }
    return true;
}

bool SpFCPortugalPorting::generateSpAction(SpPlayer *p, SpTransition *t , Action *act)
{

    int type;
    SpAction * newAction = NULL;
    char actionType = act->actionType() ;
    if(actionType == 'p')
    {
        type = SpAction::run;
        newAction = new SpAction(p, type, spSetPlay->getField());
        const fcportugal::setplay::Region * reg = ((ActPos *) act)->getRegion();

        if(dynamic_cast<const RegPoint*>(reg))
            newAction->setSpDest(regionToSpPoint(reg));
    }
    else if(actionType == 'y')
    {
        type = SpAction::pass;
        newAction = new SpAction(p, type, spSetPlay->getField());
//        PlayerReference * pr = (*((ActPass *) act)->getPlayers())[0];
        const vector<const PlayerReference*> prVector = ((ActPass *) act)->getPlayers();//JAF2014
        const PlayerReference * pr = prVector.front();//JAF2014

        SpPlayer * playerToPass = playerReferenceToSpPlayer(pr);

        QString identification = "";
//	PlayerRole * pl_r=(PlayerRole *)(pr);
//        if( pl_r!=NULL)
        if( dynamic_cast<PlayerRole*>(const_cast<PlayerReference*>(pr)) )//JAF2014 no problem using const_cast, not altering pr!
        {
 	    PlayerRole * pl_r=(PlayerRole *)(pr);
            identification = QString(pl_r->roleName().c_str());
        }
        else
            identification = " with number " + QString::number(((PlayerID *) pr)->number );
        if(!playerToPass)
        {
            error = " Error generating action pass on transition between " +
                    QString::number(t->getSource()->getIdNumber()) + " and " +
                    QString::number(t->getDest()->getIdNumber()) + ":\n" +
                    + "\nPlayer " + identification + " doesn't have be referenced before on setplay participants, so cann't receive the pass!"
                    + "\n\n Resolution: manually verify and correct the error... it's about changing player name or number of target player of action in "
                    + "transition from step "+ QString::number(t->getSource()->getIdNumber()) + " to "
                    + QString::number(t->getDest()->getIdNumber());
            return false;
        }
        newAction->setDestPlayer(playerToPass);
    }
    else if(actionType == 'd')
    {
        type = SpAction::dribble;
        newAction = new SpAction(p, type, spSetPlay->getField());
        
        const fcportugal::setplay::Region * reg = ((ActPos *) act)->getRegion();

        //RegPoint * regPoint = (RegPoint *) reg;

        if(dynamic_cast<const RegPoint*>(reg))
            newAction->setSpDest(regionToSpPoint(reg));
    }
    else if(actionType == 'h')
    {
        type = SpAction::hold;
        newAction = new SpAction(p, type, spSetPlay->getField());
    }
    else if(actionType == '0')
    {
        type = SpAction::wait;
        newAction = new SpAction(p, type, spSetPlay->getField());
    }
    else if(actionType == 'e')
    {
        type = SpAction::goToOffsideLine;
        newAction = new SpAction(p, type, spSetPlay->getField());
        const Decimal *y = ((ActMoveToOffsideLine*) act)->getY();
        QPointF dPoF = QPointF(0, y->value());
        newAction->setSpDest(new SpPoint(spSetPlay->getField(), false, dPoF));
    }
    else if(actionType == 's')
    {
        type = SpAction::shoot;
        newAction = new SpAction(p, type, spSetPlay->getField());
    }
    else if(actionType == 'v' || actionType == 'i')
    {
        return true;
    }
    else
    {
        error = "Error generating sp action t: " + QString::number(t->getIdNumber()) +
                + ", action type - " + actionType + "\n" + error;
        return false;


        error = " Error generating a action on transition between " +
                QString::number(t->getSource()->getIdNumber()) + " and " +
                QString::number(t->getDest()->getIdNumber()) + ":\n"
                + "\n The action from FCPortugal setplay framework haven't pair in Splanner actions"
                + "\n\n Resolution: manually verify and correct the error on the file... it's about changing or remove the action "
                + "on transition from step "+ QString::number(t->getSource()->getIdNumber()) + " to "
                + QString::number(t->getDest()->getIdNumber());
    }

    p->addActionToTransition(newAction, t->getIdNumber());

    return true;
}

bool SpFCPortugalPorting::generateSpPassForward(SpPlayer *p, SpTransition *t , Action *act, QList<SpPlayer *>participants)
{

    int type = SpAction::passForward;
    SpAction * newAction = new SpAction(p, type, spSetPlay->getField());
    const fcportugal::setplay::Region * reg = ((ActForward *) act)->getRegion();

    SpPoint *passPoint = regionToSpPoint(reg);

    if(passPoint)
    {
        foreach(SpPlayer *possibleDestPlayer, participants)
        {
            SpAction * action = possibleDestPlayer->getActionByTransition(t->getIdNumber());
            // como testar se o receiver está a fazer receiveBall ou Intercept????
            //if(action && action->getActor()->getAction() )

            if(action && action->getType() == SpAction::run)
            {
                SpPoint *actionPoint = action->getSpDest();
                if(*actionPoint == *passPoint)
                {
                    newAction->setDestPlayer(possibleDestPlayer);
                    newAction->setSpDest(actionPoint);
                    p->addActionToTransition(newAction, t->getIdNumber());
                    return true;
                }
            }
        }
    }

    return false;
}

SpPlayer *SpFCPortugalPorting::playerReferenceToSpPlayer(const PlayerReference* pr)//JAF2014 const PlayerReference*
{
    if( dynamic_cast<PlayerRole*>(const_cast<PlayerReference*>(pr)) )//JAF2014 no problem using const_cast since wont alter pr, just test!!!
        return spSetPlay->getPlayer(QString(((PlayerRole *) pr)->roleName().c_str()));
    else
        return spSetPlay->getPlayer( ((PlayerID *) pr)->number );
}

void SpFCPortugalPorting::playmodeToSituation(rcss::clang::PlayMode pm, int &situation, int &type)
{
    if(pm == rcss::clang::PlayOn )
    {
        // TODO default type = off
        situation = play_on;
        type = off;
    }
    else if(situation == rcss::clang::GoalieCatch_Our)
    {
        situation = keeper_catch;
        type = off;
     }
    else if(situation == rcss::clang::GoalieCatch_Opp)
    {
        situation = keeper_catch;
        type = def;
    }
    else
    {

        double s = ( ( ( (int) pm - 2 ) - 4) / 4.0) + 1.0;
        double decimalpart = s - (int) s;

        if(s > 0 && decimalpart == 0)
        {
             type = def;
             situation = s;
        }
        else
        {
             s = (double) ( ( ((int)  pm ) - 4) / 4.0) +1.0;

             decimalpart = s - (int) s;
             if(s > 0 && decimalpart == 0)
             {
                  type = off;
                  situation = s;
             }
        }
    }
}

SpPoint * SpFCPortugalPorting::regionToSpPoint(const fcportugal::setplay::Region * r)
{
    if(!dynamic_cast<const RegPoint*>(r))
        return NULL;

    const Point * ps = dynamic_cast<const RegPoint*>(r)->getPoint();
    SpPoint * spPoint = NULL;
    if(dynamic_cast<const PointSimple*>(ps))
    {
        QPointF p = toQPointF(dynamic_cast<const PointSimple*>(ps));
        spPoint = new SpPoint(spSetPlay->getField(),false, p);

    }
    else if(dynamic_cast<const PointBall*>(ps))
    {

    }
    else if(dynamic_cast<const PointRel*>(ps))
    {
        const PointRel *pr = dynamic_cast<const PointRel*>(ps);
        PointSimple * ps = new PointSimple(pr->getOffset().getX(), pr->getOffset().getY());
        QPointF offset = toQPointF(ps);
        const Point * origin = pr->getOrigin();
        if(dynamic_cast<const PointBall*>(origin))
        {
            spPoint = new SpPoint(spSetPlay->getField(),false, offset, SpPoint::ballRelative);
        }
        else if(dynamic_cast<const PointPlayer*>(origin))
        {
            const PointPlayer *pp = dynamic_cast<const PointPlayer*>(origin);
            SpPlayer *p = playerReferenceToSpPlayer(pp->getPlayer());
            spPoint = new SpPoint(spSetPlay->getField(),false, offset, p);
        }
        else if(dynamic_cast<const PointSimple*>(origin))
        {
            QPointF relativePoint(toQPointF(dynamic_cast<const PointSimple*>(origin)));
            spPoint = new SpPoint(spSetPlay->getField(),false, offset, relativePoint);
        }
    }
    return spPoint;
}

